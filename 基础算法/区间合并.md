##### 2022/4/27

### 区间合并

[https://www.acwing.com/problem/content/805/](https://www.acwing.com/problem/content/805/)

### 题目描述

<font size=2> 给定 n 个区间 [l, r]，要求合并所有有交集的区间

注意如果在端点处相交，也算有交集

输出合并完成后的区间个数

例如：[1, 3] 和 [2, 6] 可以合并为一个区间 [1, 6]</font>

<font size=2> **输入格式**

第一行包含整数 n

接下来 n 行，每行包含两个整数 l 和 r</font>

<font size=2> **输出格式**

共一行，包含一个整数，表示合并区间完成后的区间个数</font>

<font size=2> **数据范围**

1 ≤ n ≤ 100000

−10^9 ≤ l ≤ r ≤ 10^9
</font>

<font size=2> **输入样例1：**</font>

```
5
1 2
2 4
5 6
7 8
7 9
```

<font size=2> **输出样例1：**</font>

```
3
```

### 题解

#### 方法一

- <font size=2>   </font>

#### AC代码

```
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        // 读取所有的初始区间并加入到集合中
        List<pair> pairs = new ArrayList<pair>();
        for (int i = 0; i < n; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            pairs.add(new pair(a, b));
        }
        
        // 按左端点对区间排序
        Collections.sort(pairs);
        
        int count = 1;
        int end = pairs.get(0).ed;     // 表示当前维护的区间的右端点
        int start = pairs.get(0).st;   // 表示当前维护的区间的左端点
        for (pair p : pairs) {
            if (end >= p.st) end = Math.max(end, p.ed);
            else {
                count++;
                end = p.ed;
                start = p.st;
            }
        }
        
        System.out.print(count);
    }
}

class pair implements Comparable<pair> {
    int st;
    int ed;
    
    pair(int st, int ed) {
        this.st = st;
        this.ed = ed;
    }
    
    public int compareTo(pair p) {
        return this.st - p.st;
    }
}
```

#### 复杂度分析

- <font size=2>时间复杂度：O(n)</font>
- <font size=2>空间复杂度：O(1)</font>
