##### 2022/4/28

### 所有蚂蚁掉下来前的最后一刻

[https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/](https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/)

### 题目描述

<font size=2> 有一块木板，长度为 `n` 个 **单位** 。一些蚂蚁在木板上移动，每只蚂蚁都以 **每秒一个单位** 的速度移动。其中，一部分蚂蚁向 **左** 移动，其他蚂蚁向 **右** 移动。

当两只向 **不同** 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间

而当蚂蚁在某一时刻 `t` 到达木板的一端时，它立即从木板上掉下来

给你一个整数 `n` 和两个整数数组 `left` 以及 `right` 。两个数组分别标识向左或者向右移动的蚂蚁在 `t = 0` 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻</font>

<font size=2>**示例 1：**</font>

```
输入：n = 4, left = [4,3], right = [0,1]
输出：4
解释：如上图所示：
-下标 0 处的蚂蚁命名为 A 并向右移动。
-下标 1 处的蚂蚁命名为 B 并向右移动。
-下标 3 处的蚂蚁命名为 C 并向左移动。
-下标 4 处的蚂蚁命名为 D 并向左移动。
请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。
```

<font size=2>**示例 2：**</font>

```
输入：n = 7, left = [], right = [0,1,2,3,4,5,6,7]
输出：7
解释：所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。
```

<font size=2>**示例 3：**</font>

```
输入：n = 7, left = [0,1,2,3,4,5,6,7], right = []
输出：7
解释：所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。
```

<font size=2>**提示：**</font>

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

<font size=2>**进阶：**</font>

- `你能将算法的时间复杂度降低到 O(n log(n)) 吗?`

### 题解

#### 方法一、动态规划

- <font size=2>这道题是经典的线性dp，LIS问题</font>

- <font size=2>定义dp[i]表示以nums[i]为结尾的上升子序列，属性取Max</font>
- <font size=2>接下里是状态计算(分类)，我们往往认为最后一步是确定的，继而通过它的前一步去分类</font>
- <font size=2>比如说这里的dp[i]，最后一个元素就是nums[i]，于是我们可以去看它的前一个数。我们需要遍历索引小于i的所有元素并判断其是否小于nums[i]，如果小于说明nums[i]可以接到其后面，如果谁都接不上去，那么以nums[i]为结尾的上升子序列就只有它自己(此时长度为1)</font>
- <font size=2>于是可得出dp[i] = max(dp[0~i-1], 1)</font>

#### AC代码

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];

        for(int i = 0; i < n; i++) {
            dp[i] = 1;
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        
        int res = dp[0];
        for(int i = 1; i < n; i++) {
            if(res < dp[i]) res = dp[i];
        }

        return res;
    }
}
```

#### 复杂度分析

- 时间复杂度：O(n^2)，n是nums[]的长度
- 空间复杂度：O(n)，需要额外使用长度为n的dp数组

#### 方法二、贪心 + 二分

- <font size=2>如果我们要使上升子序列尽可能的长，那么我们就需要序列上升的尽可能慢，因此我们希望在已有的上升子序列最后加上的那个数要尽可能的小</font>
- <font size=2>基于上面所说，我们可以维护一个数组dp[i]，表示长度为i的最长上升子序列末尾元素的最小值，用len表示此时最长上升子序列的长度</font>
- <font size=2>我们可以发现dp[]数组是关于i单增的，如下图，如果dp[4] = C <= B，由dp[4]反推并结合dp[]数组定义可知dp[4 - 1] < dp[3]，这就表示此时B并不是dp[3]代表的那个最小值，产生矛盾，所以必然单调递增</font>
![hh](https://github.com/kunkun166/Algorithm-records/blob/main/%E6%8F%92%E5%9B%BE/01.jpg?raw=true)
- <font size=2>所以我们可以依次遍历所有元素，假设当前元素是nums[i]，在dp[0~len]范围内通过二分找到小于nums[i]的最大值dp[r]，此时有dp[r] < nums[i] < dp[r + 1]，所以nums[i]就可以替代dp[r + 1]插到dp[r]后面，如果r = len，len会加1</font>
- <font size=2>代码中，我们令l = 0是有意义的，尤其是当我们要更新dp[1]，此时二分的结果会有r = 0来兜底</font>

#### AC代码

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n + 1];

        int len = 0;
        for(int i = 0; i < n; i++) {
            int l = 0, r = len;
            while(l < r) {
                int mid = l + r + 1 >> 1;
                if(dp[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            dp[r + 1] = nums[i];
            len = Math.max(len, r + 1);
        }

        return len;
    }
}
```

#### 复杂度分析

- <font size=2>时间复杂度：O(nlogn)，n是nums[]的长度，我们只需遍历一遍数组元素，而且对于每一元素都进行二分查找</font>
- <font size=2>空间复杂度：O(n)，需要额外使用长度为n + 1的dp数组</font>
